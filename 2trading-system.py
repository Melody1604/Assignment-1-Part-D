"""
Automated Trading System with Real-time Execution
For Cross-Timezone Trading (Australian-US Markets)
Author: YUQIONG TONG
Date: 2025
"""

import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import numpy as np
import pandas as pd
from dataclasses import dataclass
from enum import Enum
import joblib

# Interactive Brokers API (TWS)
from ib_insync import IB, Stock, MarketOrder, LimitOrder, StopOrder, util
import yfinance as yf

# Kafka for real-time streaming
from kafka import KafkaProducer, KafkaConsumer
from kafka.errors import KafkaError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ====================
# DATA STRUCTURES
# ====================

class OrderType(Enum):
    MARKET = "MKT"
    LIMIT = "LMT"
    STOP = "STP"
    STOP_LIMIT = "STP LMT"

class PositionStatus(Enum):
    OPEN = "OPEN"
    CLOSED = "CLOSED"
    PENDING = "PENDING"
    CANCELLED = "CANCELLED"

@dataclass
class TradingSignal:
    """Trading signal generated by strategies"""
    timestamp: datetime
    symbol: str
    action: str  # BUY, SELL, HOLD
    confidence: float
    strategy: str
    suggested_quantity: int
    suggested_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

@dataclass
class Position:
    """Active position tracking"""
    symbol: str
    quantity: int
    entry_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float
    status: PositionStatus
    entry_time: datetime
    strategy: str

# ====================
# STRATEGY MODULES
# ====================

class TradingStrategy:
    """Base class for trading strategies"""
    
    def __init__(self, name: str, risk_limit: float = 0.02):
        self.name = name
        self.risk_limit = risk_limit
        self.active = True
        
    def generate_signal(self, market_data: Dict) -> Optional[TradingSignal]:
        """Generate trading signal based on market data"""
        raise NotImplementedError

class MSTYVolatilityStrategy(TradingStrategy):
    """MSTY Volatility-Volume Strategy"""
    
    def __init__(self):
        super().__init__("MSTY_Volatility")
        self.volatility_threshold = 1.5  # Standard deviations
        self.volume_multiplier = 1.2
        
    def generate_signal(self, market_data: Dict) -> Optional[TradingSignal]:
        """Generate signal based on volatility and volume patterns"""
        symbol = market_data['symbol']
        current_volatility = market_data.get('volatility', 0)
        avg_volatility = market_data.get('avg_volatility', 1)
        volume_ratio = market_data.get('volume_ratio', 1)
        
        # High volatility with increased volume suggests opportunity
        if current_volatility > avg_volatility * self.volatility_threshold:
            if volume_ratio > self.volume_multiplier:
                # Volatility breakout signal
                return TradingSignal(
                    timestamp=datetime.now(),
                    symbol=symbol,
                    action="BUY" if market_data['price_trend'] > 0 else "SELL",
                    confidence=0.67,  # From paper results
                    strategy=self.name,
                    suggested_quantity=self._calculate_position_size(market_data),
                    stop_loss=market_data['price'] * 0.98,
                    take_profit=market_data['price'] * 1.04
                )
        return None
    
    def _calculate_position_size(self, market_data: Dict) -> int:
        """Calculate position size based on volatility"""
        base_size = 100
        volatility_factor = market_data.get('volatility', 1) / market_data.get('avg_volatility', 1)
        
        # Reduce position size for higher volatility
        if volatility_factor > 1.5:
            return int(base_size * 0.5)
        elif volatility_factor > 1.2:
            return int(base_size * 0.75)
        return base_size

class TLTMacroEventStrategy(TradingStrategy):
    """TLT Macro Event Timing Strategy"""
    
    def __init__(self):
        super().__init__("TLT_Macro")
        self.event_window_hours = 2
        
    def generate_signal(self, market_data: Dict) -> Optional[TradingSignal]:
        """Generate signal around macro events"""
        upcoming_events = market_data.get('economic_events', [])
        
        for event in upcoming_events:
            time_to_event = (event['time'] - datetime.now()).total_seconds() / 3600
            
            if 0 < time_to_event < self.event_window_hours:
                # Position for macro event
                if event['importance'] == 'HIGH':
                    return TradingSignal(
                        timestamp=datetime.now(),
                        symbol='TLT',  # Treasury ETF
                        action="BUY",  # Flight to safety
                        confidence=0.45,
                        strategy=self.name,
                        suggested_quantity=50,
                        stop_loss=market_data['price'] * 0.99
                    )
        return None

class TechStockPatternStrategy(TradingStrategy):
    """Technology Stock Gap-Fill Pattern Strategy"""
    
    def __init__(self):
        super().__init__("Tech_Pattern")
        self.tech_symbols = ['AAPL', 'GOOGL', 'MSFT', 'NVDA', 'META']
        
    def generate_signal(self, market_data: Dict) -> Optional[TradingSignal]:
        """Identify gap-fill patterns in tech stocks"""
        symbol = market_data['symbol']
        
        if symbol not in self.tech_symbols:
            return None
            
        gap_size = market_data.get('gap_percentage', 0)
        
        # Look for significant gaps
        if abs(gap_size) > 1.5:
            # Fade the gap (contrarian)
            action = "SELL" if gap_size > 0 else "BUY"
            
            return TradingSignal(
                timestamp=datetime.now(),
                symbol=symbol,
                action=action,
                confidence=0.38,
                strategy=self.name,
                suggested_quantity=100,
                stop_loss=market_data['price'] * (0.97 if action == "BUY" else 1.03)
            )
        return None

class ForexHedgeStrategy(TradingStrategy):
    """Forex Hedging Protocol for Cross-Timezone Trading"""
    
    def __init__(self):
        super().__init__("Forex_Hedge")
        self.hedge_threshold = 0.02  # 2% currency move
        
    def generate_signal(self, market_data: Dict) -> Optional[TradingSignal]:
        """Generate forex hedge signals"""
        aud_usd_change = market_data.get('aud_usd_change', 0)
        
        if abs(aud_usd_change) > self.hedge_threshold:
            # Hedge currency exposure
            return TradingSignal(
                timestamp=datetime.now(),
                symbol='FXA',  # AUD/USD ETF
                action="SELL" if aud_usd_change > 0 else "BUY",
                confidence=0.71,
                strategy=self.name,
                suggested_quantity=200,
                stop_loss=None  # No stop for hedges
            )
        return None

# ====================
# RISK MANAGEMENT
# ====================

class RiskManager:
    """Risk management and position sizing"""
    
    def __init__(self, max_position_size: float = 50000,
                 max_daily_loss: float = 1000,
                 max_concentration: float = 0.3):
        self.max_position_size = max_position_size
        self.max_daily_loss = max_daily_loss
        self.max_concentration = max_concentration
        self.daily_pnl = 0
        self.positions = {}
        
    def validate_trade(self, signal: TradingSignal, current_price: float) -> Tuple[bool, str]:
        """Validate if trade meets risk criteria"""
        position_value = signal.suggested_quantity * current_price
        
        # Check position size limit
        if position_value > self.max_position_size:
            return False, f"Position size ${position_value:.2f} exceeds limit"
        
        # Check daily loss limit
        if self.daily_pnl < -self.max_daily_loss:
            return False, f"Daily loss limit reached: ${self.daily_pnl:.2f}"
        
        # Check concentration limit
        portfolio_value = sum(pos['value'] for pos in self.positions.values())
        if portfolio_value > 0:
            concentration = position_value / (portfolio_value + position_value)
            if concentration > self.max_concentration:
                return False, f"Concentration {concentration:.2%} exceeds limit"
        
        return True, "Trade approved"
    
    def calculate_position_size(self, signal: TradingSignal, 
                              volatility: float, 
                              account_balance: float) -> int:
        """Calculate risk-adjusted position size"""
        # Kelly Criterion simplified
        win_rate = signal.confidence
        avg_win = 0.02  # 2% average win
        avg_loss = 0.01  # 1% average loss
        
        kelly_fraction = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
        kelly_fraction = max(0, min(kelly_fraction, 0.25))  # Cap at 25%
        
        # Adjust for volatility
        volatility_adjustment = 1 / (1 + volatility)
        
        # Calculate position size
        position_value = account_balance * kelly_fraction * volatility_adjustment
        shares = int(position_value / signal.suggested_price) if signal.suggested_price else signal.suggested_quantity
        
        return max(1, shares)

# ====================
# EXECUTION ENGINE
# ====================

class ExecutionEngine:
    """Handle order execution and management"""
    
    def __init__(self, ib_client: IB, risk_manager: RiskManager):
        self.ib = ib_client
        self.risk_manager = risk_manager
        self.active_orders = {}
        self.executed_trades = []
        
    async def execute_signal(self, signal: TradingSignal) -> bool:
        """Execute trading signal"""
        try:
            # Get current market data
            contract = Stock(signal.symbol, 'SMART', 'USD')
            ticker = self.ib.reqMktData(contract)
            await asyncio.sleep(1)  # Wait for data
            
            current_price = ticker.marketPrice()
            
            # Validate trade with risk manager
            is_valid, message = self.risk_manager.validate_trade(signal, current_price)
            if not is_valid:
                logger.warning(f"Trade rejected: {message}")
                return False
            
            # Create order
            if signal.suggested_price:
                order = LimitOrder(
                    action=signal.action,
                    totalQuantity=signal.suggested_quantity,
                    lmtPrice=signal.suggested_price
                )
            else:
                order = MarketOrder(
                    action=signal.action,
                    totalQuantity=signal.suggested_quantity
                )
            
            # Place order
            trade = self.ib.placeOrder(contract, order)
            self.active_orders[trade.order.orderId] = {
                'signal': signal,
                'trade': trade,
                'timestamp': datetime.now()
            }
            
            logger.info(f"Order placed: {signal.symbol} {signal.action} {signal.suggested_quantity} @ {current_price:.2f}")
            
            # Set stop loss if specified
            if signal.stop_loss:
                stop_order = StopOrder(
                    action="SELL" if signal.action == "BUY" else "BUY",
                    totalQuantity=signal.suggested_quantity,
                    stopPrice=signal.stop_loss
                )
                self.ib.placeOrder(contract, stop_order)
            
            return True
            
        except Exception as e:
            logger.error(f"Execution error: {e}")
            return False
    
    def monitor_positions(self):
        """Monitor and manage active positions"""
        for position in self.ib.positions():
            symbol = position.contract.symbol
            
            # Check for exit conditions
            if self._should_exit_position(position):
                self._close_position(position)
    
    def _should_exit_position(self, position) -> bool:
        """Determine if position should be closed"""
        # Implement exit logic based on:
        # - Stop loss hit
        # - Take profit reached
        # - Time-based exit (overnight positions)
        # - Risk limit breach
        return False
    
    def _close_position(self, position):
        """Close an open position"""
        contract = position.contract
        quantity = position.position
        
        # Create closing order
        action = "SELL" if quantity > 0 else "BUY"
        order = MarketOrder(action=action, totalQuantity=abs(quantity))
        
        trade = self.ib.placeOrder(contract, order)
        logger.info(f"Closing position: {contract.symbol} {quantity}")

# ====================
# MAIN TRADING SYSTEM
# ====================

class AutomatedTradingSystem:
    """Main automated trading system orchestrator"""
    
    def __init__(self, config_path: str = 'config.json'):
        self.config = self._load_config(config_path)
        self.ib = None
        self.strategies = []
        self.risk_manager = None
        self.execution_engine = None
        self.ml_model = None
        self.is_running = False
        
    def _load_config(self, config_path: str) -> Dict:
        """Load system configuration"""
        with open(config_path, 'r') as f:
            return json.load(f)
    
    def initialize(self):
        """Initialize system components"""
        logger.info("Initializing Automated Trading System...")
        
        # Connect to Interactive Brokers
        self.ib = IB()
        self.ib.connect(
            self.config['ib']['host'],
            self.config['ib']['port'],
            clientId=self.config['ib']['client_id']
        )
        
        # Initialize strategies
        self.strategies = [
            MSTYVolatilityStrategy(),
            TLTMacroEventStrategy(),
            TechStockPatternStrategy(),
            ForexHedgeStrategy()
        ]
        
        # Initialize risk manager
        self.risk_manager = RiskManager(
            max_position_size=self.config['risk']['max_position_size'],
            max_daily_loss=self.config['risk']['max_daily_loss']
        )
        
        # Initialize execution engine
        self.execution_engine = ExecutionEngine(self.ib, self.risk_manager)
        
        # Load ML model
        self.ml_model = joblib.load('xgboost_model.pkl')
        
        logger.info("System initialized successfully")
    
    async def run(self):
        """Main trading loop"""
        self.is_running = True
        logger.info("Starting automated trading system...")
        
        while self.is_running:
            try:
                # Check if US market is open
                if not self._is_market_open():
                    await asyncio.sleep(60)
                    continue
                
                # Get market data
                market_data = await self._fetch_market_data()
                
                # Generate signals from each strategy
                signals = []
                for strategy in self.strategies:
                    if strategy.active:
                        signal = strategy.generate_signal(market_data)
                        if signal:
                            signals.append(signal)
                
                # ML model validation
                validated_signals = self._validate_with_ml(signals, market_data)
                
                # Execute validated signals
                for signal in validated_signals:
                    await self.execution_engine.execute_signal(signal)
                
                # Monitor existing positions
                self.execution_engine.monitor_positions()
                
                # Update risk metrics
                self._update_risk_metrics()
                
                # Send summary to user (22:00 Sydney time)
                if datetime.now().hour == 22:
                    self._send_daily_summary()
                
                # Sleep before next iteration
                await asyncio.sleep(self.config['system']['loop_interval'])
                
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                await asyncio.sleep(60)
    
    def _is_market_open(self) -> bool:
        """Check if US market is open (accounting for timezone)"""
        # US market hours: 9:30 AM - 4:00 PM EST
        # Convert to Sydney time (AEDT = EST + 16 hours)
        now = datetime.now()
        market_open = now.replace(hour=1, minute=30)  # 1:30 AM Sydney
        market_close = now.replace(hour=8, minute=0)   # 8:00 AM Sydney
        
        return market_open <= now <= market_close
    
    async def _fetch_market_data(self) -> Dict:
        """Fetch real-time market data"""
        market_data = {}
        
        # Get watchlist symbols
        symbols = self.config['watchlist']
        
        for symbol in symbols:
            try:
                # Get real-time data from IB
                contract = Stock(symbol, 'SMART', 'USD')
                ticker = self.ib.reqMktData(contract, '', False, False)
                await asyncio.sleep(0.5)
                
                # Get historical data for indicators
                bars = self.ib.reqHistoricalData(
                    contract,
                    endDateTime='',
                    durationStr='1 D',
                    barSizeSetting='5 mins',
                    whatToShow='TRADES',
                    useRTH=True
                )
                
                # Calculate indicators
                df = util.df(bars)
                
                market_data[symbol] = {
                    'symbol': symbol,
                    'price': ticker.marketPrice(),
                    'bid': ticker.bid,
                    'ask': ticker.ask,
                    'volume': ticker.volume,
                    'volatility': df['close'].pct_change().std() * np.sqrt(252),
                    'avg_volatility': df['close'].pct_change().rolling(20).std().mean() * np.sqrt(252),
                    'volume_ratio': ticker.volume / df['volume'].mean() if df['volume'].mean() > 0 else 1,
                    'price_trend': (ticker.marketPrice() - df['close'].iloc[-20]) / df['close'].iloc[-20],
                    'gap_percentage': (df['open'].iloc[-1] - df['close'].iloc[-2]) / df['close'].iloc[-2] * 100
                }
                
            except Exception as e:
                logger.error(f"Error fetching data for {symbol}: {e}")
        
        # Add economic events (mock for now)
        market_data['economic_events'] = []
        
        # Add forex data
        market_data['aud_usd_change'] = self._get_forex_change()
        
        return market_data
    
    def _get_forex_change(self) -> float:
        """Get AUD/USD exchange rate change"""
        try:
            forex = yf.Ticker("AUDUSD=X")
            hist = forex.history(period="1d")
            return (hist['Close'].iloc[-1] - hist['Open'].iloc[-1]) / hist['Open'].iloc[-1]
        except:
            return 0.0
    
    def _validate_with_ml(self, signals: List[TradingSignal], market_data: Dict) -> List[TradingSignal]:
        """Validate signals using ML model"""
        validated = []
        
        for signal in signals:
            # Prepare features for ML model
            features = self._prepare_ml_features(signal, market_data.get(signal.symbol, {}))
            
            # Get ML prediction
            prediction = self.ml_model.predict_proba([features])[0][1]
            
            # Combine strategy confidence with ML prediction
            combined_confidence = (signal.confidence + prediction) / 2
            
            if combined_confidence > 0.5:
                signal.confidence = combined_confidence
                validated.append(signal)
        
        return validated
    
    def _prepare_ml_features(self, signal: TradingSignal, market_data: Dict) -> List[float]:
        """Prepare features for ML model"""
        # Match features from training
        features = [
            signal.suggested_quantity,
            market_data.get('price', 0),
            signal.suggested_quantity * market_data.get('price', 0),
            market_data.get('price_trend', 0) * 100,
            0.001,  # commission rate estimate
            market_data.get('volatility', 0),
            market_data.get('volatility', 0) * np.log1p(signal.suggested_quantity * market_data.get('price', 0)),
            datetime.now().hour,
            datetime.now().weekday(),
            1 if 9 <= datetime.now().hour < 16 else 0,
            1.0,  # price_to_ma5 placeholder
            1.0,  # price_to_ma20 placeholder
            market_data.get('volume_ratio', 1),
            0,  # prev_pnl placeholder
            market_data.get('avg_volatility', 0),
            market_data.get('volatility', 0) * signal.suggested_quantity * market_data.get('price', 0)
        ]
        
        return features
    
    def _update_risk_metrics(self):
        """Update risk management metrics"""
        # Calculate daily P&L
        daily_pnl = sum(pos.dailyPnL for pos in self.ib.positions())
        self.risk_manager.daily_pnl = daily_pnl
        
        # Update position values
        self.risk_manager.positions = {
            pos.contract.symbol: {
                'value': abs(pos.position * pos.marketPrice),
                'pnl': pos.unrealizedPnL
            }
            for pos in self.ib.positions()
        }
    
    def _send_daily_summary(self):
        """Send daily summary to user (22:00 Sydney time)"""
        summary = {
            'date': datetime.now().strftime('%Y-%m-%d'),
            'positions': len(self.risk_manager.positions),
            'daily_pnl': self.risk_manager.daily_pnl,
            'active_strategies': [s.name for s in self.strategies if s.active],
            'alerts': []
        }
        
        # Log summary (in production, send via email/SMS)
        logger.info(f"Daily Summary: {json.dumps(summary, indent=2)}")
        
        # Check for critical alerts
        if self.risk_manager.daily_pnl < -self.risk_manager.max_daily_loss * 0.8:
            summary['alerts'].append("Approaching daily loss limit")
        
        return summary
    
    def stop(self):
        """Stop the trading system"""
        logger.info("Stopping automated trading system...")
        self.is_running = False
        
        # Close all positions if configured
        if self.config['system'].get('close_on_stop', False):
            for position in self.ib.positions():
                self.execution_engine._close_position(position)
        
        # Disconnect from IB
        if self.ib:
            self.ib.disconnect()
        
        logger.info("System stopped")

# ====================
# MAIN ENTRY POINT
# ====================

async def main():
    """Main entry point"""
    # Create and initialize system
    system = AutomatedTradingSystem('config.json')
    system.initialize()
    
    # Run the system
    try:
        await system.run()
    except KeyboardInterrupt:
        logger.info("Received shutdown signal")
    finally:
        system.stop()

if __name__ == "__main__":
    asyncio.run(main())
